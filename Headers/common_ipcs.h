#ifndef TEST_H__
#define TEST_H__
#define _GNU_SOURCE
#include <stdio.h>
#include <math.h>
#include <sys/shm.h>
#include <signal.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/sem.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <sys/msg.h>

/*da leggere a tempo di compilazione*/
#define SO_REGISTRY_SIZE 1000
#define SO_BLOCK_SIZE 5

/*macro personali */
#define CLOCK_REALTIME 0
#define MAX_PRINT_USERS 0
#define MAX_PRINT_NODES 0

/* macro sender */
#define my_macro(x) x<-1 ? -(x) : (x)


typedef struct _transaction{
  pid_t sender;
  pid_t receiver;
  long timestamp;
  int quantity;
  int reward;
  int n_of_hops;
}Transaction;

/* -da leggere a tempo di esecuzione/stdin 
   -leggi sulle slide CAPITOLO 7 per la spiegazione di queste variabili */
typedef struct _config{
  int SO_USERS_NUM;
  int SO_NODES_NUM;
  int SO_INIT_BUDGET;
  int SO_REWARD;
  long SO_MIN_TRANS_GEN_NSEC;
  long SO_MAX_TRANS_GEN_NSEC;
  int SO_RETRY;
  int SO_TP_SIZE;
  long SO_MIN_TRANS_PROC_NSEC;
  long SO_MAX_TRANS_PROC_NSEC;
  long SO_SIM_SEC;
  int SO_NUM_FRIENDS;
  int SO_HOPS;
}Config;

/*blocco di transazioni da processare or processate*/
typedef struct _block{
  int id;
  Transaction transactions[SO_BLOCK_SIZE]; 
}Block;

/* structure needed in order to use semaphores */
union semun {
  int val;    /* Value for SETVAL */
  struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
  unsigned short  *array;  /* Array for GETALL, SETALL */
  struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */
};

/* transaction queue, with message type(long) and trans_queue(Transaction) */
typedef struct _message {
  long msg_type;
  Transaction transaction;
}Message;

/*contains the ids of the momory block of the Shared Memory -- book,nodes,users and message Queue */
typedef struct shared_memory_IDs{
  int book_id; 
  int nodes_id;
  int users_id;
  int msgQ_id;
  int sem_id;
  int config_id;
}shm_id;

typedef struct _ledger{
  int last_id;
  Block array_of_blocks[SO_REGISTRY_SIZE];
}Ledger;

typedef struct _nodes{
  pid_t pid;
  int reward_sum;
  int n_transQ;
  pid_t friends[100];
}Node;

typedef struct _user{
  pid_t pid;
  int budget;
  unsigned int dead; /* -1 if the user died before time */
}User;





/*
  SEMAPHORES
*/


/**
 * @brief locks in a resource using semctl()
 */
void semLock(int sem_ID,int index);

/**
 * @brief release a resource using semctl() previously locked in
 */
void semRelease(int sem_ID,int index);

/**
 * @brief sets semaphore value to 1
 * 
 * @param sem_ID the id of the IPC
 * @param index the index of the semaphore
 */
void semSet_disp(int sem_ID,int index);

void semSet_inUse(int sem_ID,int index);

/*
  SHARED MEMORY
*/


/**
 * @brief used by createSHM -- uses shmget() to create a new Shared Memory block
 * @param key the key generated by ftok()
 * @param size the size of the memory block
 * @return return the id of the memory block
 */
int generateSHM(key_t key, int size);

/**
 * @brief destroy the desired block of shared memory
 * @param id the id of the Shared Memory block
 */
void destroySHM(int id);
/**
 * @brief calls destroySHM a few times on different SHM blocks,uses free()
 * @param ids_free the ids to the segment of the memory to detach
 */
void freeMemory(shm_id ids_free);

/**
 * @brief create Shared Memory for the book,nodes and users ET creates the message Queue ET an array of semaphores
 * put the ids the memory block on the struct shm_ID
 * @param source the file path
 * @return returns the struct with all the configs
 */
shm_id createIPCs(const char* source,int users,int nodes);

/**
 * @brief attach to the Shared Memory
 * @param shm_id the id of the part of the Shared Memory to attach to
 * @return shmat return casted to void*
 */
void* attachSHM(int shm_id);

/**
 * @brief choose the node to send the transaction to
 * @return the node to send the process to
 */
int chooseRandNode(int num);

#endif  